---
title: 'This Week in Mojo 2023-06-30'
date: 2023-06-30
author: Mojo Dojo
author_site: https://mojodojo.dev
author_image: https://mojodojo.dev/hero.png
head:
  - [meta, { name: twitter:card , content: summary }]
  - [meta, { name: twitter:site , content: '@mojodojodev' }]
  - [meta, { name: twitter:title , content: This Week in Mojo }]
  - [meta, { name: twitter:description , content: "This week in Mojo with language updates, community content, and everything else related to Mojo" }]
  - [meta, { name: twitter:image , content: "https://mojodojo.dev/hero.png" }]
---

![Logo](/hero.png)

# This Week in Mojo 2023-06-30
## Community
- [Code & Tech](https://www.youtube.com/@Code-Tech) released a video: [What is MojoðŸ”¥?](https://www.youtube.com/watch?v=S1H6_GqfTdg)

## Mojo Team Answers
### Macros
I think it is important to have some sort of macro-like feature for syntax - one specific use-case for this is to enable things like "parallel_for" to be library features instead of language features. That said, we aren't looking to implement language features for their own sake, we should be motivated by specific problems we want to solve.
- [2023-06-25 GitHub Chris Lattner](https://github.com/modularml/mojo/discussions/410#discussioncomment-6269717)

### Multiple Dispatch
This is a nice feature from (eg) Julia, but it depends entirely on its compilation model which doesn't work the same way as Mojo's.
- [2023-06-25 GitHub Chris Lattner](https://github.com/modularml/mojo/issues/407#issuecomment-1605594829)

### Python Type Hints
Mojo can tell the difference between Python "hints" and Mojo types. There will be no problem here, we can support the hints for compatibility (by ignoring them) just like Python does.
- [2023-06-25 GitHub Chris Lattner](https://github.com/modularml/mojo/discussions/410#discussioncomment-6269717)

### Rust
I don't think that mojo has any burden to prove novelty vs rust.  We're happy to adopt good ideas from Rust as with all other existing languages. Graydon himself was very happy for Rust to pull good ideas when he started it, and wasn't ashamed to admit it.  Mojo is similar.

I also don't see Rust and Mojo in competition, while I'm hoping that Mojo can learn from and improve vs Rust in various areas, they're clearly servicing different segments of the world. Yes there is some crossover, but Rust is far more mature than Mojo and Rust is continuously improving as well. If you'd like to continue using Rust, go for it ðŸ˜€.

If you're interested in language nerdery, then yes, there are ways in which Mojo can provide better performance than Rust. There are two categories:

1. There are very low level implementation details (e.g. borrow by default instead of move, moves not implying memcpy etc) that can affect idiomatic use of the language at scale. As others say, it will be difficult to know how these work out until Mojo is more complete and there are more at-scale applications like your caching system. Mojo's trait system in particular is missing, and it's hard to write much realistic generic code without that! 

2. Mojo open new frontiers for GPUs and other accelerators. We can all have different opinions about what the "end of moore's" law means for computing, but if computers keep getting weirder, and if that matters for important workloads that you care about, then Mojo will be interesting because it can talk to them in ways that other languages weren't really built for.

That said if you care about Fibonacci on X86 cpus, both Rust and Mojo (and Clang and many many others) are all zero cost languages that boil down to LLVM. As such, any advantage claimed on such a workload will be more about accidental implementation details than anything else and could be easily fixed.
